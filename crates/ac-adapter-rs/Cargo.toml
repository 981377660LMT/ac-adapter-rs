[package]
name = "ac-adapter-rs"
version = "0.1.0"
authors = ["Kana <ngtkana@gmail.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
accum = { path = "../utils/accum" }
advance = { path = "../utils/advance" }
bfs = { path = "../algolib/bfs" }
bfs01 = { path = "../algolib/bfs01" }
binary = { path = "../utils/binary" }
bitset = { path = "../utils/bitset" }
box_segtree = { path = "../range-query/box_segtree" }
bsgs = { path = "../math/bsgs" }
convex_hull = { path = "../geometry/convex_hull" }
dbg = { path = "../utils/dbg" }
dfs = { path = "../algolib/dfs" }
dial = { path = "../algolib/dial" }
dijkstra_radix_heap = { path = "../algolib/dijkstra_radix_heap" }
dinic = { path = "../flow/dinic" }
elim = { path = "../linear-algebra/elim" }
erato = { path = "../math/erato" }
euclid = { path = "../math/euclid" }
filter_position = { path = "../iterator/filter_position" }
fp = { path = "../fp/fp" }
fps = { path = "../fp/fps" }
gco = { path = "../flow/gco" }
grid = { path = "../utils/grid" }
gridtools = { path = "../utils/gridtools" }
hld = { path = "../tree-decomposition/hld" }
hopkarp = { path = "../flow/hopkarp" }
hungarian = { path = "../flow/hungarian" }
inversion_number = { path = "../algolib/inversion_number" }
lagrange = { path = "../fp/lagrange" }
lazy_segbeats = { path = "../range-query/lazy_segbeats" }
lazy_segtree = { path = "../range-query/lazy_segtree" }
make_graph = { path = "../utils/make_graph" }
max_flow = { path = "../algolib/max_flow" }
montgomery = { path = "../fp/montgomery" }
newton = { path = "../math/newton" }
next_permutation = { path = "../utils/next_permutation" }
ngtio = { path = "../utils/ngtio" }
not_nan = { path = "../utils/not_nan" }
open = { path = "../utils/open" }
ordtools = { path = "../utils/ordtools" }
partially_persistent_union_find = { path = "../disjoint_set/partially_persistent_union_find" }
prefix_sum = { path = "../utils/prefix_sum" }
radix_heap = { path = "../algolib/radix_heap" }
randtools = { path = "../utils/randtools" }
rational = { path = "../math/rational" }
rbtree = { path = "../balanced-tree/rbtree" }
reverse = { path = "../utils/reverse" }
scc = { path = "../algolib/scc" }
segbeats = { path = "../range-query/segbeats" }
segbeats_task3 = { path = "../range-query/segbeats_task3" }
segtree = { path = "../range-query/segtree" }
seq = { path = "../utils/seq" }
skew-heap = { path = "../heaps/skew-heap" }
sort_tree = { path = "../algolib/sort_tree" }
space = { path = "../utils/space" }
span = { path = "../utils/span" }
sparse_table = { path = "../range-query/sparse_table" }
suffix_array = { path = "../algolib/suffix_array" }
swag = { path = "../range-query/swag" }
tree_fold = { path = "../algolib/tree_fold" }
trial = { path = "../math/trial" }
trie = { path = "../string/trie" }
uf_checklist = { path = "../range-query/uf_checklist" }
union_find = { path = "../disjoint_set/union_find" }
vec_lines = { path = "../algolib/vec_lines" }
z_algorithm = { path = "../algolib/z_algorithm" }
zeta = { path = "../algolib/zeta" }
