use std::fmt::Debug;

/// 畳み込み演算を定義します。
///
/// # `dp[x]` の定義
///
/// * `x` が葉ならば、`self.leaf(x)`
/// * `x` が葉でないならば、
///
/// ```[ignore]
/// self.finish(
///     g[x].iter()
///         .map(|&y| &dp[y])
///         .fold(self.init(x), |acc, value| self.mul(acc, value)),
///     x,
/// ),
/// ```
///
/// # `index` について
///
/// `mul` には `index` がありません。なぜなら `leaf` や `finish` で担保できるからです。
///
///
pub trait Ops {
    type Value: Clone + Debug + Default;
    type Acc: Clone + Debug;
    fn leaf(&self, index: usize) -> Self::Value;
    fn init(&self, index: usize) -> Self::Acc;
    fn mul(&self, acc: Self::Acc, value: &Self::Value) -> Self::Acc;
    fn finish(&self, acc: Self::Acc, index: usize) -> Self::Value;

    /// 木 DP をする基本的なメソッドです。
    fn tree_fold_by<O: Ops, I: Iterator<Item = usize>, J: Iterator<Item = usize>>(
        &self,
        n: usize,
        ord_rev: I,
        child: impl Fn(usize) -> J,
    ) -> Self::Value {
        let mut dp = vec![Self::Value::default(); n];
        for o in ord_rev {
            let child = child(o);
        }
        todo!()
    }
}
